{"uid":"c6ee9ee752fabefe","name":"test_refresh_transfer","fullName":"test.spec.test_refresh_transfer#test_refresh_transfer","historyId":"d1ab47a5274f9aa6225c3573d1873f92","time":{"start":1763725688282,"stop":1763725688282,"duration":0},"description":"Test for refresh transfer","descriptionHtml":"<p>Test for refresh transfer</p>\n","status":"broken","statusMessage":"configparser.DuplicateOptionError: While reading from '/home/runner/.local/share/python_keyring/keyring_pass.cfg' [line  8]: option 'wallet_5fpassword_5ftest_5fapp_5f1_5fregtest' in section 'iriswallet_5Ftest_5Fapp_5F1' already exists","statusTrace":"item = <Function test_refresh_transfer>\n\n    @pytest.hookimpl(wrapper=True, tryfirst=True)\n    def pytest_runtest_setup(item):\n        \"\"\"\n        Hook called after before test setup starts, to start capturing exceptions\n        as early as possible.\n        \"\"\"\n        capture_enabled = _is_exception_capture_enabled(item)\n        if capture_enabled:\n            item.qt_exception_capture_manager = _QtExceptionCaptureManager()\n            item.qt_exception_capture_manager.start()\n>       result = yield\n\n../../../.cache/pypoetry/virtualenvs/iris-wallet-desktop-2iCMAhbc-py3.12/lib/python3.12/site-packages/pytestqt/plugin.py:180: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ne2e_tests/test/utilities/app_setup.py:278: in test_environment\n    env = TestEnvironment(\ne2e_tests/test/utilities/app_setup.py:63: in __init__\n    self.remove_keyring_entries(service=FIRST_SERVICE, app_name=APP1_NAME)\ne2e_tests/test/utilities/app_setup.py:260: in remove_keyring_entries\n    keyring.delete_password(service, f\"{key}_{app_name}\")\n../../_temp/pydeps/keyring/core.py:75: in delete_password\n    get_keyring().delete_password(service_name, username)\n../../_temp/pydeps/keyrings/alt/file_base.py:175: in delete_password\n    config.read(self.file_path, encoding='utf-8')\n/opt/hostedtoolcache/Python/3.12.3/x64/lib/python3.12/configparser.py:684: in read\n    self._read(fp, filename)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <configparser.RawConfigParser object at 0x7f0740b29940>\nfp = <_io.TextIOWrapper name='/home/runner/.local/share/python_keyring/keyring_pass.cfg' mode='r' encoding='utf-8'>\nfpname = '/home/runner/.local/share/python_keyring/keyring_pass.cfg'\n\n    def _read(self, fp, fpname):\n        \"\"\"Parse a sectioned configuration file.\n    \n        Each section in a configuration file contains a header, indicated by\n        a name in square brackets (`[]`), plus key/value options, indicated by\n        `name` and `value` delimited with a specific substring (`=` or `:` by\n        default).\n    \n        Values can span multiple lines, as long as they are indented deeper\n        than the first line of the value. Depending on the parser's mode, blank\n        lines may be treated as parts of multiline values or ignored.\n    \n        Configuration files may include comments, prefixed by specific\n        characters (`#` and `;` by default). Comments may appear on their own\n        in an otherwise empty line or may be entered in lines holding values or\n        section names. Please note that comments get stripped off when reading configuration files.\n        \"\"\"\n        elements_added = set()\n        cursect = None                        # None, or a dictionary\n        sectname = None\n        optname = None\n        lineno = 0\n        indent_level = 0\n        e = None                              # None, or an exception\n        try:\n            for lineno, line in enumerate(fp, start=1):\n                comment_start = sys.maxsize\n                # strip inline comments\n                inline_prefixes = {p: -1 for p in self._inline_comment_prefixes}\n                while comment_start == sys.maxsize and inline_prefixes:\n                    next_prefixes = {}\n                    for prefix, index in inline_prefixes.items():\n                        index = line.find(prefix, index+1)\n                        if index == -1:\n                            continue\n                        next_prefixes[prefix] = index\n                        if index == 0 or (index > 0 and line[index-1].isspace()):\n                            comment_start = min(comment_start, index)\n                    inline_prefixes = next_prefixes\n                # strip full line comments\n                for prefix in self._comment_prefixes:\n                    if line.strip().startswith(prefix):\n                        comment_start = 0\n                        break\n                if comment_start == sys.maxsize:\n                    comment_start = None\n                value = line[:comment_start].strip()\n                if not value:\n                    if self._empty_lines_in_values:\n                        # add empty line to the value, but only if there was no\n                        # comment on the line\n                        if (comment_start is None and\n                            cursect is not None and\n                            optname and\n                            cursect[optname] is not None):\n                            cursect[optname].append('') # newlines added at join\n                    else:\n                        # empty line marks end of value\n                        indent_level = sys.maxsize\n                    continue\n                # continuation line?\n                first_nonspace = self.NONSPACECRE.search(line)\n                cur_indent_level = first_nonspace.start() if first_nonspace else 0\n                if (cursect is not None and optname and\n                    cur_indent_level > indent_level):\n                    cursect[optname].append(value)\n                # a section header or option header?\n                else:\n                    indent_level = cur_indent_level\n                    # is it a section header?\n                    mo = self.SECTCRE.match(value)\n                    if mo:\n                        sectname = mo.group('header')\n                        if sectname in self._sections:\n                            if self._strict and sectname in elements_added:\n                                raise DuplicateSectionError(sectname, fpname,\n                                                            lineno)\n                            cursect = self._sections[sectname]\n                            elements_added.add(sectname)\n                        elif sectname == self.default_section:\n                            cursect = self._defaults\n                        else:\n                            cursect = self._dict()\n                            self._sections[sectname] = cursect\n                            self._proxies[sectname] = SectionProxy(self, sectname)\n                            elements_added.add(sectname)\n                        # So sections can't start with a continuation line\n                        optname = None\n                    # no section header in the file?\n                    elif cursect is None:\n                        raise MissingSectionHeaderError(fpname, lineno, line)\n                    # an option line?\n                    else:\n                        mo = self._optcre.match(value)\n                        if mo:\n                            optname, vi, optval = mo.group('option', 'vi', 'value')\n                            if not optname:\n                                e = self._handle_error(e, fpname, lineno, line)\n                            optname = self.optionxform(optname.rstrip())\n                            if (self._strict and\n                                (sectname, optname) in elements_added):\n>                               raise DuplicateOptionError(sectname, optname,\n                                                           fpname, lineno)\nE                                                          configparser.DuplicateOptionError: While reading from '/home/runner/.local/share/python_keyring/keyring_pass.cfg' [line  8]: option 'wallet_5fpassword_5ftest_5fapp_5f1_5fregtest' in section 'iriswallet_5Ftest_5Fapp_5F1' already exists\n\n/opt/hostedtoolcache/Python/3.12.3/x64/lib/python3.12/configparser.py:1075: DuplicateOptionError","flaky":false,"newFailed":false,"newBroken":false,"newPassed":false,"retriesCount":0,"retriesStatusChange":false,"beforeStages":[{"name":"test_environment","time":{"start":1763725688282,"stop":1763725688283,"duration":1},"status":"broken","statusMessage":"configparser.DuplicateOptionError: While reading from '/home/runner/.local/share/python_keyring/keyring_pass.cfg' [line  8]: option 'wallet_5fpassword_5ftest_5fapp_5f1_5fregtest' in section 'iriswallet_5Ftest_5Fapp_5F1' already exists\n","statusTrace":"  File \"/home/runner/.cache/pypoetry/virtualenvs/iris-wallet-desktop-2iCMAhbc-py3.12/lib/python3.12/site-packages/pluggy/_callers.py\", line 167, in _multicall\n    teardown.throw(outcome._exception)\n  File \"/home/runner/.cache/pypoetry/virtualenvs/iris-wallet-desktop-2iCMAhbc-py3.12/lib/python3.12/site-packages/_pytest/setuponly.py\", line 36, in pytest_fixture_setup\n    return (yield)\n            ^^^^^\n  File \"/home/runner/.cache/pypoetry/virtualenvs/iris-wallet-desktop-2iCMAhbc-py3.12/lib/python3.12/site-packages/pluggy/_callers.py\", line 103, in _multicall\n    res = hook_impl.function(*args)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/runner/.cache/pypoetry/virtualenvs/iris-wallet-desktop-2iCMAhbc-py3.12/lib/python3.12/site-packages/_pytest/fixtures.py\", line 1140, in pytest_fixture_setup\n    result = call_fixture_func(fixturefunc, request, kwargs)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/runner/.cache/pypoetry/virtualenvs/iris-wallet-desktop-2iCMAhbc-py3.12/lib/python3.12/site-packages/_pytest/fixtures.py\", line 891, in call_fixture_func\n    fixture_result = next(generator)\n                     ^^^^^^^^^^^^^^^\n  File \"/home/runner/work/iris-wallet-desktop/iris-wallet-desktop/e2e_tests/test/utilities/app_setup.py\", line 278, in test_environment\n    env = TestEnvironment(\n          ^^^^^^^^^^^^^^^^\n  File \"/home/runner/work/iris-wallet-desktop/iris-wallet-desktop/e2e_tests/test/utilities/app_setup.py\", line 63, in __init__\n    self.remove_keyring_entries(service=FIRST_SERVICE, app_name=APP1_NAME)\n  File \"/home/runner/work/iris-wallet-desktop/iris-wallet-desktop/e2e_tests/test/utilities/app_setup.py\", line 260, in remove_keyring_entries\n    keyring.delete_password(service, f\"{key}_{app_name}\")\n  File \"/home/runner/work/_temp/pydeps/keyring/core.py\", line 75, in delete_password\n    get_keyring().delete_password(service_name, username)\n  File \"/home/runner/work/_temp/pydeps/keyrings/alt/file_base.py\", line 175, in delete_password\n    config.read(self.file_path, encoding='utf-8')\n  File \"/opt/hostedtoolcache/Python/3.12.3/x64/lib/python3.12/configparser.py\", line 684, in read\n    self._read(fp, filename)\n  File \"/opt/hostedtoolcache/Python/3.12.3/x64/lib/python3.12/configparser.py\", line 1075, in _read\n    raise DuplicateOptionError(sectname, optname,\n","steps":[],"attachments":[],"parameters":[],"stepsCount":0,"shouldDisplayMessage":true,"attachmentsCount":0,"hasContent":true,"attachmentStep":false}],"afterStages":[],"labels":[{"name":"story","value":"Test for refresh transfer from home refresh and then check the status to success after mine the transaction"},{"name":"feature","value":"Test for refresh transfer"},{"name":"parentSuite","value":"test.spec"},{"name":"suite","value":"test_refresh_transfer"},{"name":"host","value":"runnervmfxdz0"},{"name":"thread","value":"5646-MainThread"},{"name":"framework","value":"pytest"},{"name":"language","value":"cpython3"},{"name":"package","value":"test.spec.test_refresh_transfer"},{"name":"resultFormat","value":"allure2"}],"parameters":[],"links":[],"hidden":false,"retry":false,"extra":{"severity":"normal","retries":[],"categories":[{"name":"Test defects","matchedStatuses":[],"flaky":false}],"tags":[]},"source":"c6ee9ee752fabefe.json","parameterValues":[]}